---
share: true
tags:
  - 保护模式
  - 实模式
  - A20
  - GDT
categories: 
title: ucore操作系统实验：lab1-练习3
date: 2023-12-16 20:00:04
update: 2023-12-16 20:11:37
---

## 练习内容

![](/images/ucore操作系统实验：lab1-练习3_image_1.png)

## 问题解答

**问题 1：为何开启 A20，以及如何开启 A20**

**A20 问题来源**

> A20 指的是计算机中第 21 根地址总线。

早期的 intel 8086 和 intel 8088 中有 20 根地址总线，理论上可以访问的地址空间大小为 $2^{20}=1M$ ,但由于该系列的 CPU 中只有 16 根数据总线，  所以实际上能够表示的地址范围仅为 0~64K 。

为了可以访问到全部的 1M 内存空间，intel 采用了如下的地址计算方式：

$$内存地址 = (段基地址 << 4) + 偏移量$$

此时可以获得的最大地址为：

$$
\begin{equation}
\begin{aligned}
最大内存地址 &= 最大段基地址 << 4 + 最大偏移量 \\
					& = FFFF << 4 + FFFF \\
                      &= FFFF0 + FFFF \\
                      &= 10FFEF \\
                      & = 1M + 64KB -16B
\end{aligned}
\end{equation}
$$

可以看到在计算地址的过程中有可能会出现地址大于 1M 的越界现象，对于这些越界的地址（ 100000~10FFEF），intel 8086 和 intel 8088 会采用 wrap-around 技术来处理，直白点讲就是将地址对 1M 进行求模。

CPU 发展到 intel 80286 时，地址总线变为了 24 根，能够访问的地址空间变为了 $2^{24}=16M$，之前的对于 intel 8086 和 intel 8088 而言的越界地址（ 100000~10FFEF），在 intel 80286 中已经不算越界了。不过为了兼容之前的 CPU，使系统表现的行为不发生变化，出现了 A20 Gate。
- 当 A20 处于关闭状态时，第 21 一根地址总线的值总是 0，此时访问地址 100000~10FFEF 实际访问到的是 0~FFEF，  表现的如同在 intel 8086 和 intel 8088 中一样；
- 当 A20 处于开启状态时，第 21 根地址总线的值既可以为 0 也可以为 1，那么就可以正常的访问 100000~10FFEF 这一段空间。  

**实模式和实模式**

实模式可以简单的理解为 Intel 80286 出现之前 CPU 的工作模式，它的特点是直接使用真实的物理地址访问内存，可使用的内存地址空间为 1M，对所有可寻址内存、I/O 地址和外设硬件的访问没有限制，不支持内存保护、多任务处理和特权级等。保护模式是 Intel 80286 之后出现的 CPU 的工作模式，与实模式最大区别是用逻辑地址代替了真实地址，可以采用分段存储管理机制和分页存储管理机制，不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。同时保护模式下通过提供 4 个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。

因为 Intel 80286 之后的 CPU 是向前兼容的，所以它们本身都支持实模式，目前大部分计算机启动时也都是先在实模式下运行，之后再跳转到保护模式。

**开启 A20 的原因**

计算机在启动时首先运行在实模式，为了跟早先的 CPU 兼容，实模式下 A20 都处于关闭状态，此时如果不开启 A20，那么跳转到保护模式后，能访问到的真实物理内存只有 `0-1M`, `2-3M`, `4-5M` 等奇数内存，所以想要访问完整的内存空间必须开启 A20。

**开启 A20 的方法**

根据提示阅读 `lab1/boot/bootasm.S` ，其中开启 A20 的代码如下，在 ucore 实验中通过控制键盘控制器实现 A20 的开启。

```asm
seta20.1:
    inb $0x64, %al           # 从0x64端口读取键盘控制器状态到al寄存器中
    testb $0x2, %al          # 判断al寄存器第2为是否为1，如果是执行下一条指令
    jnz seta20.1             # 跳转到seta20.1重新执行

    movb $0xd1, %al          # 设置al寄存器的值为 0xd1
    outb %al, $0x64          # 将al中的值写入0x64端口

seta20.2:
    inb $0x64, %al            # 从0x64端口读取键盘控制器状态到al寄存器中
    testb $0x2, %al           # 判断al寄存器第2为是否为1，如果是执行下一条指令
    jnz seta20.2              # 跳转到seta20.2重新执行

    movb $0xdf, %al           # 设置al寄存器的值为 0xdf
    outb %al, $0x60           # 将al中的值写入0x60端口
```

所以开启 A20 的整个步骤为：

- 向键盘控制器的 `0x64` 端口发送的命令 `0xd1`，即代码段 `seta20.1` 完成的工作；
- 向键盘控制器的 `0x60` 端口发送的命令 `0xdf`，即代码段 `seta20.2` 完成的工作；

**问题 2：如何初始化 GDT 表**

ucore 在 `lab1/boot/bootasm.S` 文件尾部定义 GDT 表，代码如下：

```asm
# Bootstrap GDT
.p2align 2                                  # force 4 byte alignment
gdt:
    SEG_NULLASM                             # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg for bootloader and kernel

gdtdesc:
    .word 0x17                              # sizeof(gdt) - 1
    .long gdt                               # address gdt
```

其中 `gdt` 为 ucore 中构造出的 GDT ，`gdtdesc` 记录了 GDT 的长度和内存地址，在 `lab1/boot/bootasm.S` 中有如下这么一条指令，它的作用是将 `gdtdesc` 处的数据读取到全局描述符表寄存器 GDTR 中。

```asm
lgdt gdtdesc
```


**问题 3：如何使能和进入保护模式**

在 CPU 中有一个 `CR0` 寄存器，包含了 6 个预定义标志，第 0 位是保护允许位 PE ( Protedted Enable )，用于启动保护模式，如果 PE 位置 1，则保护模式启动，如果 PE=0，则在实模式下运行。所以启动保护模式只需要将 `CR0` 寄存器第 0 位设为 1 即可，相关代码如下：

```asm
movl %cr0, %eax
orl $CR0_PE_ON, %eax
movl %eax, %cr0
```
